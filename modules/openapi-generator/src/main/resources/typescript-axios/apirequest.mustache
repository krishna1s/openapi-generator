import { test, expect } from '@playwright/test';
import { createRequestFunction } from '../../.lib/common';
import fs from 'fs';
import path from 'path';
import { TestData } from "./data/{{testDataFileName}}"
import { SwaggerValidator } from '../../.lib/schemaValidator.ts';

let swaggerPath = '../swagger.json'
let validator = new SwaggerValidator(swaggerPath);

// Location from where user provided data for tests will be taken
let dataDirectory = 'data';

{{#operations}}
{{#operation}}
// {{summary}}
test.describe('{{operationId}}', function() {

    test('{{operationId}} - Valid Inputs', async () => {
        // Check if a file called '{{operationId}}_{{httpMethod}}' exists, otherwise use generated data
        var expectedDataFileName = '{{operationId}}_{{httpMethod}}.json';
        var dataFileWithPath = path.join(dataDirectory, expectedDataFileName);
        if (fs.existsSync(dataFileWithPath)) {
            let fileContent = fs.readFileSync(dataFileWithPath, 'utf-8');
            let testData = JSON.parse(fileContent);
            console.log(testData);
            let response = await createRequestFunction('{{operationId}}', '1', testData);

            // TODO: status code validation pending
        }
    });

{{#scenarios}}
    test('{{scenario}}', async () => {
	    let testData = TestData['{{operationId}}']["scenarios"]['{{-index}}'];
        let response = await createRequestFunction('{{operationId}}', '{{-index}}', testData);
        expect(response.status).toBe({{expectedOutcome.statusCode}});
        {{#valid}}

        // Check response in case of valid test expected outcome.
        let validationErrors = validator.validateAgainstDefinition('{{returnType}}', response.data);
        let errors: string[] = []
        validationErrors.errors.forEach(error => errors.push(error.message + ", at path: " + error.path + "."));
        expect(errors.length, "Response Validation Failed.\n" + errors.join("\n")).toBe(0);
        {{/valid}}
    });
{{/scenarios}}
});
{{/operation}}

{{/operations}}